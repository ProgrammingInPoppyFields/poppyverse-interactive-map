<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Poppyverse Graph — CSV Loader (Glow fix)</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0b12; overflow:hidden; }
    #g { width:100vw; height:100vh; }

    /* Legend overlay */
    #legend {
      position: fixed; top: 14px; left: 14px; z-index: 10;
      background: rgba(0,0,0,.58);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 12px;
      padding: 16px 18px;
      color: #fff;
      font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      max-width: 46vw; backdrop-filter: blur(4px);
    }
    #legend h3 { margin: 0 0 10px 0; font-size: 18px; letter-spacing: .02em; opacity:.97; }
    #legend .row { display:flex; align-items:center; gap:12px; margin: 8px 0; }
    #legend .swatch { width: 18px; height: 18px; border-radius: 5px; border:1px solid rgba(255,255,255,.28); box-shadow: 0 0 16px rgba(255,20,71,.22); }
    #legend .label { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 34vw; opacity:.95; }

    /* Tooltip */
    .poppy-label {
      color: #fff;
      font: 18px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    .poppy-label b {
      color: #FF1447; text-shadow: 0 0 10px #FF1447;
    }
    .poppy-label .hint { opacity:.9; font-size: 16px; }
  </style>
</head>
<body>
  <div id="g"></div>
  <div id="legend" hidden>
    <h3>Legend (Tags → color)</h3>
    <div id="legend-rows"></div>
  </div>

  <!-- Three.js (custom glow), 3d-force-graph, PapaParse -->
  <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/3d-force-graph"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
  // ====== CSV file probing ======
  // Browser can't list the folder; try a few likely names that contain "the poppy board".
  const CSV_CANDIDATES = [
    'the poppy board.csv',
    'the poppy board, v2 28b95a1c19ee80249fb2fd23fc0b9532.csv',
    'the poppy board v2.csv',
    'table.csv'
  ];
  async function fetchFirstCsv() {
    for (const name of CSV_CANDIDATES) {
      try {
        const res = await fetch(name, { cache: 'no-cache' });
        if (res.ok) return await res.text();
      } catch(e) { /* try next */ }
    }
    throw new Error('CSV not found. Add your actual filename to CSV_CANDIDATES.');
  }

  // flexible column names (case-insensitive)
  const COLNAMES = {
    id:       ['id','node id','uid','slug'],
    name:     ['name','title','label'],
    tags:     ['tag','tags','category','categories'],
    size:     ['size','val','value','weight'],
    sequels:  ['sequels','sequel','next','edges','to'],
    collision:['collision','collisions','collide','also to'],
    url:      ['url','link','href','permalink']
  };

  // On-brand palette: poppy/red/pink/purple + monochrome (distinct)
  const THEME_PALETTE = [
    '#FF1447', // poppy
    '#FF3C74', // hot pink-poppy
    '#FF6FA0', // rose neon
    '#FF99C2', // light rose
    '#D96AFF', // magenta-violet
    '#A64DFF', // electric purple
    '#7A3DFF', // deep violet
    '#5A2A82', // royal grape
    '#FFFFFF', // white
    '#C8C8C8', // light gray
    '#8A8A8A', // mid gray
    '#4A4A4A'  // dark gray
  ];
  // Extend with magenta/purple tints if you have more tags than palette
  function hslToHex(h, s, l){
    const c=(1-Math.abs(2*l-1))*s, x=c*(1-Math.abs(((h/60)%2)-1)), m=l-c/2;
    let [r,g,b]=(h<60)?[c,x,0]:(h<120)?[x,c,0]:(h<180)?[0,c,x]:(h<240)?[0,x,c]:(h<300)?[x,0,c]:[c,0,x];
    const to255 = v => Math.round((v+m)*255);
    return `#${to255(r).toString(16).padStart(2,'0')}${to255(g).toString(16).padStart(2,'0')}${to255(b).toString(16).padStart(2,'0')}`.toUpperCase();
  }
  function extendOnTheme(i){
    const hue = 315 - ((i * 17) % 30); // stay near magenta/purple band
    const s = 0.92, l = Math.max(0.35, 0.58 - (i % 4) * 0.06);
    return hslToHex(hue, s, l);
  }

  // utils
  function normalizeHeaders(fields){
    const map={}; (fields||[]).forEach(f=>{ const key=String(f||'').trim().toLowerCase(); map[key]=f; }); return map;
  }
  function pick(headers, aliases){
    for(const a of aliases){
      const k=a.toLowerCase();
      if(k in headers) return headers[k];
      for(const key in headers){ if(key.includes(k)) return headers[key]; }
    }
    return null;
  }
  function splitIds(s){
    if(!s) return [];
    return String(s).split(/[,;|]/).map(x=>x.trim()).filter(Boolean);
  }
  function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }
  function toSize(x){
    if (x===null || x===undefined || String(x).trim()==='') return 5; // default
    const n = Number(String(x).trim());
    return clamp(Number.isFinite(n) ? n : 5, 1, 10);
  }
  function hexToRgb(hex){
    const s = hex.replace('#','');
    return { r: parseInt(s.slice(0,2),16), g: parseInt(s.slice(2,4),16), b: parseInt(s.slice(4,6),16) };
  }
  function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

  // ====== load + build ======
  fetchFirstCsv()
    .then(txt => new Promise(resolve => Papa.parse(txt, { header:true, dynamicTyping:false, skipEmptyLines:true, complete:resolve })))
    .then(result => {
      const rows = result.data || [];
      if (!rows.length) throw new Error('CSV has no rows');

      const headers = normalizeHeaders(result.meta.fields || Object.keys(rows[0]||{}));
      const col = {
        id:       pick(headers, COLNAMES.id),
        name:     pick(headers, COLNAMES.name),
        tags:     pick(headers, COLNAMES.tags),
        size:     pick(headers, COLNAMES.size),
        sequels:  pick(headers, COLNAMES.sequels),
        collision:pick(headers, COLNAMES.collision),
        url:      pick(headers, COLNAMES.url)
      };
      if (!col.id && col.name) col.id = col.name;

      // nodes
      const idSet = new Set();
      const nodes = rows.map(r => {
        const id   = String(r[col.id] ?? r[col.name] ?? '').trim();
        if (!id) return null;
        const name = String(r[col.name] ?? id).trim();
        const tag  = String(r[col.tags] ?? '').trim() || '(untagged)';
        const url  = ((r[col.url] ?? '') + '').trim() || null;
        const size = toSize(r[col.size]); // 1..10 (default 5)

        idSet.add(id);
        return { id, label: name, tag, url, val: size };
      }).filter(Boolean);

      // tag → color mapping (on-brand)
      const tagsOrder = [];
      const seen = new Set();
      for (const n of nodes){ if (!seen.has(n.tag)) { seen.add(n.tag); tagsOrder.push(n.tag); } }
      const tagColor = {};
      tagsOrder.forEach((t, i) => {
        tagColor[t] = i < THEME_PALETTE.length ? THEME_PALETTE[i] : extendOnTheme(i - THEME_PALETTE.length);
      });
      nodes.forEach(n => n.color = tagColor[n.tag]);

      // links (sequels + collision share same style for now)
      const links = [];
      rows.forEach(r => {
        const src = String(r[col.id] ?? r[col.name] ?? '').trim();
        if (!src) return;
        const targets = [...splitIds(r[col.sequels]), ...splitIds(r[col.collision])];
        targets.forEach(tgt => {
          if (!tgt) return;
          if (!idSet.has(tgt)) {
            idSet.add(tgt);
            nodes.push({ id: tgt, label: tgt, tag: '(referenced)', val: 5, color: '#CCCCCC', url: null });
          }
          links.push({ source: src, target: tgt, color: 'rgba(255,255,255,0.55)', width: 1.9 });
        });
      });

      // legend
      const legend = document.getElementById('legend');
      const rowsEl = document.getElementById('legend-rows');
      rowsEl.innerHTML = '';
      tagsOrder.forEach(t => {
        const row = document.createElement('div'); row.className='row';
        const sw = document.createElement('div'); sw.className='swatch';
        sw.style.background = tagColor[t];
        sw.style.boxShadow = `0 0 16px ${tagColor[t]}`;
        const la = document.createElement('div'); la.className='label'; la.textContent = t;
        row.appendChild(sw); row.appendChild(la); rowsEl.appendChild(row);
      });
      legend.hidden = false;

      // ===== Glow fix: canvas gradient uses rgba(), not URL-escaped hex =====
      const glowTexCache = {};
      function makeGlowTexture(hex){
        if (glowTexCache[hex]) return glowTexCache[hex];

        const { r, g, b } = hexToRgb(hex);
        const size = 256;
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = size;
        const ctx = canvas.getContext('2d');

        const grd = ctx.createRadialGradient(size/2, size/2, size*0.05, size/2, size/2, size*0.5);
        // bright inner core -> colored body -> transparent edge
        grd.addColorStop(0.00, 'rgba(255,255,255,1.0)');
        grd.addColorStop(0.15, `rgba(${r},${g},${b},0.95)`);
        grd.addColorStop(0.40, `rgba(${r},${g},${b},0.65)`);
        grd.addColorStop(1.00, 'rgba(0,0,0,0)');

        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, size, size);

        const tex = new THREE.CanvasTexture(canvas);
        tex.needsUpdate = true;
        glowTexCache[hex] = tex;
        return tex;
      }
      function makeGlowSprite(hex){
        const map = makeGlowTexture(hex);
        const mat = new THREE.SpriteMaterial({
          map,
          color: 0xffffff,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          opacity: 0.85
        });
        const spr = new THREE.Sprite(mat);
        spr.scale.set(1,1,1);
        return spr;
      }

      // build graph
      const elem = document.getElementById('g');
      let hoveredNode = null, pulseRAF = null;

      const Graph = ForceGraph3D()(elem)
        .graphData({ nodes, links })
        .backgroundColor('#000014')
        .showNavInfo(false)
        // custom node: ×3 size multiplier + sprite glow
        .nodeThreeObject(n => {
          const colorHex = n.color || '#FF1447';
          const color = new THREE.Color(colorHex);

          // core sphere
          const baseRadius = 5;
          const coreGeo = new THREE.SphereGeometry(baseRadius, 24, 24);
          const coreMat = new THREE.MeshStandardMaterial({ color, metalness: 0.15, roughness: 0.35 });
          const core = new THREE.Mesh(coreGeo, coreMat);

          // scale by val (1..10) with ×3 multiplier
          const s = (Math.max(1, Math.min(10, n.val || 5)) / 5) * 3.0;
          core.scale.set(s, s, s);

          // sprite glow
          const glow = makeGlowSprite(colorHex);
          const glowBaseSize = baseRadius * s * 8;
          glow.scale.set(glowBaseSize, glowBaseSize, 1);
          glow.material.opacity = 0.35; // idle
          core.add(glow);

          // cache
          n.__core = core;
          n.__glow = glow;
          n.__sizeScale = s;
          return core;
        })
        // tooltip: bigger font + URL hint
        .nodeLabel(n => {
          const urlHint = n.url ? '<span class="hint">Click to open archive</span>' : '<span class="hint">URL: N/A</span>';
          const tag = n.tag ? `<br><span style="opacity:.9; font-size: 16px">${escapeHtml(n.tag)}</span>` : '';
          return `<div class="poppy-label"><b>${escapeHtml(n.label || n.id)}</b>${tag}<br>${urlHint}</div>`;
        })
        // links
        .linkColor(l => l.color || 'rgba(255,255,255,0.55)')
        .linkWidth(l => l.width || 1.9)
        .linkOpacity(1);

      // scene lights
      const scene = Graph.scene();
      scene.add(new THREE.AmbientLight(0xffffff, 0.4));
      const dir = new THREE.DirectionalLight(0xffffff, 0.7); dir.position.set(60, 80, 40); scene.add(dir);

      // hover pulse/glow animation
      function pulse() {
        if (!hoveredNode || !hoveredNode.__glow || !hoveredNode.__core) { pulseRAF = requestAnimationFrame(pulse); return; }
        const t = (Date.now() % 1200) / 1200;
        const k = 1 + 0.18 * Math.sin(t * Math.PI * 2);
        const o = 0.35 + 0.35 * (0.5 + 0.5 * Math.sin(t * Math.PI * 2));
        const base = hoveredNode.__sizeScale;

        hoveredNode.__core.scale.set(base * 1.08, base * 1.08, base * 1.08);
        const baseGlow = 5 * base * 8;
        hoveredNode.__glow.scale.set(baseGlow * k, baseGlow * k, 1);
        hoveredNode.__glow.material.opacity = o;

        pulseRAF = requestAnimationFrame(pulse);
      }

      // UX
      Graph
        .onNodeHover((node, prev) => {
          // restore previous
          if (prev && prev.__core && prev.__glow) {
            const b = prev.__sizeScale;
            prev.__core.scale.set(b, b, b);
            prev.__glow.material.opacity = 0.35;
          }
          hoveredNode = node || null;

          if (hoveredNode) {
            elem.style.cursor = 'pointer';
            if (!pulseRAF) pulseRAF = requestAnimationFrame(pulse);
          } else {
            elem.style.cursor = null;
            if (pulseRAF) { cancelAnimationFrame(pulseRAF); pulseRAF = null; }
          }
        })
        .onNodeClick(n => { if (n.url) window.open(n.url, '_blank', 'noopener'); });

    })
    .catch(err => {
      document.body.innerHTML = '<pre style="color:#fff; padding:16px">'+String(err)+'</pre>';
      console.error(err);
    });
  </script>
</body>
</html>
