<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Poppyverse Graph — Compact Space, Positive Axes</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0b12; overflow:hidden; }
    #g { width:100vw; height:100vh; }

    /* Legend (collapsed by default) */
    #legend {
      position: fixed; top: 14px; left: 14px; z-index: 10;
      background: rgba(0,0,0,.58);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 12px;
      padding: 10px 12px 12px 12px;
      color: #fff;
      font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      max-width: 50vw; backdrop-filter: blur(4px);
      pointer-events: auto; user-select: none;
    }
    #legend header { display:flex; align-items:center; justify-content:space-between; gap:10px; cursor:pointer; padding:4px 2px; }
    #legend h3 { margin:0; font-size:18px; letter-spacing:.02em; opacity:.97; }
    #legend .toggle {
      width:26px; height:26px; border-radius:8px;
      border:1px solid rgba(255,255,255,.25);
      display:flex; align-items:center; justify-content:center;
      font-size:16px; line-height:1; opacity:.9;
    }
    #legend .rows { margin-top:8px; }
    #legend .row { display:flex; align-items:center; gap:12px; margin:8px 0; }
    #legend .swatch { width:18px; height:18px; border-radius:5px; border:1px solid rgba(255,255,255,.28); box-shadow:0 0 12px rgba(255,255,255,.18); }
    #legend .label { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:38vw; opacity:.95; }
    #legend.collapsed .rows { display:none; }
    #legend.collapsed .toggle { opacity:.7; }
    #legend .static-link { margin-top:6px; font-size:14px; opacity:.95; }
    #legend .static-link a { color:#FF1447; text-decoration:none; border-bottom:1px dashed #FF1447; }
    #legend .static-link a:hover { text-decoration:underline; }

    /* Tooltip */
    .poppy-label { color:#fff; font:18px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .poppy-label b { text-shadow:0 0 10px currentColor; }
    .poppy-label .hint { opacity:.9; font-size:16px; }
  </style>
</head>
<body>
  <div id="g"></div>

  <!-- Collapsed by default -->
  <div id="legend" class="collapsed" hidden>
    <header id="legend-toggle">
      <h3>Universe clusters (color key)</h3>
      <div class="toggle" aria-label="Toggle legend" title="Toggle legend">▸</div>
    </header>
    <div class="rows" id="legend-rows"></div>
    <div class="static-link">
      Prefer a calmer, saner static index? See the <a href="https://inpoppyfields.tumblr.com/map" target="_blank" rel="noopener">Story Map</a>.
    </div>
  </div>

  <!-- Three.js, 3d-force-graph, PapaParse -->
  <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/3d-force-graph"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
  // ===== CSV candidates (same folder) =====
  const CSV_CANDIDATES = [
    'table.csv','table - export.csv','table (export).csv',
    'the poppy board.csv','the poppy board v2.csv',
    'the poppy board, v2 28b95a1c19ee80249fb2fd23fc0b9532.csv'
  ];
  async function fetchFirstCsv() {
    for (const name of CSV_CANDIDATES) {
      try { const res = await fetch(name, { cache: 'no-cache' }); if (res.ok) return await res.text(); } catch {}
    }
    throw new Error('CSV not found. Add your filename to CSV_CANDIDATES (must contain "table" or "the poppy board").');
  }

  // Flexible columns
  const COLNAMES = {
    id: ['id','node id','uid','slug'],
    name: ['name','title','label'],
    tags: ['tag','tags','category','categories'], // Universe cluster
    size: ['size','val','value','weight'],       // 1..30 or "(X) whatever"
    content: ['content'], meta: ['meta'], relatable: ['relatable'], // XYZ numeric in parentheses
    sequels: ['sequels','sequel','next','edges','to'],
    collision: ['collision','collisions','collide','also to'],
    url: ['url','link','href','permalink']
  };

  // ===== Palette: poppy → pink → purple → cyan =====
  const TAG_PALETTE = [
    '#FF1447', '#FF2E7A', '#FF5AC8', '#C243FF',
    '#8A3DFF', '#4F6CFF', '#1CC6FF', '#00E5FF'
  ];
  function lerp(a,b,t){return a+(b-a)*t;}
  function hexToRgb(hex){const s=String(hex).replace('#','');return {r:parseInt(s.slice(0,2),16),g:parseInt(s.slice(2,4),16),b:parseInt(s.slice(4,6),16)};}
  function rgbToHex(r,g,b){const h=v=>v.toString(16).padStart(2,'0');return '#'+h(r)+h(g)+h(b);}
  function extendCool(i){
    const a = hexToRgb(TAG_PALETTE[TAG_PALETTE.length-2]);
    const b = hexToRgb(TAG_PALETTE[TAG_PALETTE.length-1]);
    const t = (i % 6) / 6;
    return rgbToHex(Math.round(lerp(a.r,b.r,t)), Math.round(lerp(a.g,b.g,t)), Math.round(lerp(a.b,b.b,t)));
  }

  // ===== Position / spread knobs (CLOSER but not overlapping) =====
  // Reduced overall scale & spacing; still adds spiral de-overlap + jitter.
  const POS_SCALE    = 220;  // was ~950 → closer clusters
  const CLUSTER_BASE = 28;   // base spacing for equal triples (was 48)
  const CLUSTER_STEP = 20;   // growth per duplicate (was 32)
  const RANDOM_RADIAL= 26;   // extra spiral radius randomness (was 48)
  const BASE_JITTER  = 18;   // base 3D jitter (was 26)
  const EXTRA_JITTER = 26;   // extra randomized jitter (was 40)

  // Axis names (X,Y,Z) — positive-only, white lines
  const AXIS_NAMES = {
    x: 'Lumen threshold',        // Content
    y: 'Metaphysical drift',     // Meta
    z: 'Proximity to home'       // Relatability
  };

  // Utils
  function normalizeHeaders(fields){const m={};(fields||[]).forEach(f=>{m[String(f||'').trim().toLowerCase()]=f;});return m;}
  function pick(headers, aliases){for(const a of aliases){const k=a.toLowerCase();if(k in headers) return headers[k];for(const key in headers){if(key.includes(k)) return headers[key];}}return null;}
  function splitIdsFlexible(s){if(s==null) return [];const raw=String(s).trim();if(!raw) return [];return raw.split(/[\s,;|]+/).map(t=>t.trim()).filter(Boolean).map(t=>Number(t)).filter(n=>Number.isFinite(n));}
  function parseParenNumber(s,fb=null){const m=/\(\s*([-+]?\d*\.?\d+)\s*\)/.exec(String(s||''));return m?Number(m[1]):fb;}
  function toSize(s){ const fromParen = parseParenNumber(s); const n = (fromParen!=null ? fromParen : (s==null||s==='' ? 5 : Number(s))); const v = Number.isFinite(n) ? n : 5; return Math.max(1, Math.min(30, v)); }
  function escapeHtml(s){return String(s||'').replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));}
  function hash32(str){let h=2166136261>>>0; for(let i=0;i<str.length;i++){h^=str.charCodeAt(i);h=Math.imul(h,16777619);} return h>>>0;}
  function rand(seed){ seed = (seed + 0x6D2B79F5) >>> 0; let t = Math.imul(seed ^ (seed >>> 15), 1 | seed); t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t; return ((t ^ (t >>> 14)) >>> 0) / 4294967296; }

  // Cache legend elements ONCE
  const legendEl = document.getElementById('legend');
  const rowsEl   = document.getElementById('legend-rows');
  const toggleEl = document.getElementById('legend-toggle');

  // ====== load data ======
  fetchFirstCsv()
    .then(txt => new Promise(res => Papa.parse(txt,{header:true,dynamicTyping:false,skipEmptyLines:true,complete:res})))
    .then(result => {
      const rows = result.data||[];
      if(!rows.length) throw new Error('CSV has no rows');

      const headers = normalizeHeaders(result.meta.fields||Object.keys(rows[0]||{}));
      const col = {
        id: pick(headers,COLNAMES.id) || pick(headers,COLNAMES.name),
        name: pick(headers,COLNAMES.name),
        tags: pick(headers,COLNAMES.tags),
        size: pick(headers,COLNAMES.size),
        content: pick(headers,COLNAMES.content),
        meta: pick(headers,COLNAMES.meta),
        relatable: pick(headers,COLNAMES.relatable),
        sequels: pick(headers,COLNAMES.sequels),
        collision: pick(headers,COLNAMES.collision),
        url: pick(headers,COLNAMES.url)
      };
      if(!col.id || !col.tags) throw new Error('Need at least ID/NAME and TAG columns');

      // ---------- Nodes (compact XYZ + spiral de-overlap + jitter) ----------
      const nodeBuckets = Object.create(null); // "x|y|z" -> count
      const nodes = rows.map(r=>{
        const id = String(r[col.id] ?? '').trim();
        const label = String(r[col.name] ?? id).trim() || id;
        const cluster = String(r[col.tags] ?? '').trim() || '(unclustered)';
        if(!id || !cluster) return null;

        const url = ((r[col.url] ?? '') + '').trim() || null;
        const size = toSize(r[col.size]);

        // parse "(X) part" for XYZ (Content→x, Meta→y, Relatable→z)
        const xv=parseParenNumber(r[col.content],0), yv=parseParenNumber(r[col.meta],0), zv=parseParenNumber(r[col.relatable],0);
        const TX=(Number.isFinite(xv)?xv:0)*POS_SCALE, TY=(Number.isFinite(yv)?yv:0)*POS_SCALE, TZ=(Number.isFinite(zv)?zv:0)*POS_SCALE;

        const bucketKey = `${xv}|${yv}|${zv}`;
        nodeBuckets[bucketKey]=(nodeBuckets[bucketKey]||0);
        const idx = nodeBuckets[bucketKey]++;

        const seed = hash32(id + '|' + bucketKey);
        const r1 = rand(seed), r2 = rand(seed+1), r3 = rand(seed+2), r4 = rand(seed+3);

        const PHI=2.399963229728653;
        const baseRadius = CLUSTER_BASE + CLUSTER_STEP * Math.sqrt(idx);
        const radius = baseRadius + (r1 - 0.5) * 2 * RANDOM_RADIAL;
        const angle  = idx * PHI + r2 * Math.PI * 2;

        const jAmp = BASE_JITTER + r3 * EXTRA_JITTER;
        const jx = (r4*2 - 1) * jAmp;
        const jy = (rand(seed+4)*2 - 1) * jAmp;
        const jz = (rand(seed+5)*2 - 1) * jAmp;

        const dx = radius * Math.cos(angle) + jx;
        const dy = radius * Math.sin(angle) + jy;
        const dz = jz;

        const x = TX + dx, y = TY + dy, z = TZ + dz;

        return {
          id, label, cluster, url, val:size,
          x, y, z, fx:x, fy:y, fz:z, tx:x, ty:y, tz:z,
          color: null,
          _dbg: { seed, idx, baseRadius, radius, angle, jx, jy, jz, TX, TY, TZ }
        };
      }).filter(Boolean);

      // maps for links
      const nodeById = new Map(), nodeByNum = new Map();
      nodes.forEach(n=>{ nodeById.set(String(n.id), n); const num=Number(n.id); if(Number.isFinite(num)) nodeByNum.set(num, n); });

      // Universe cluster → color
      const clusterOrder=[], seen=new Set(), clusterColor={};
      nodes.forEach(n=>{ if(!seen.has(n.cluster)){seen.add(n.cluster); clusterOrder.push(n.cluster);} });
      clusterOrder.forEach((t,i)=>{ clusterColor[t]= i<TAG_PALETTE.length ? TAG_PALETTE[i] : extendCool(i-TAG_PALETTE.length); });
      nodes.forEach(n=> n.color = clusterColor[n.cluster]);

      // ensure node for stubs
      function ensureNodeForId(raw){
        const key = String(raw);
        let node = nodeById.get(key);
        if (node) return node;
        node = { id:key, label:key, cluster:'(referenced)', url:null, val:5,
                 x:0,y:0,z:0, fx:0,fy:0,fz:0, tx:0,ty:0,tz:0, color:'#00E5FF', _dbg:{seed:0} };
        nodes.push(node);
        nodeById.set(key, node);
        const num=Number(key); if(Number.isFinite(num)) nodeByNum.set(num, node);
        return node;
      }

      // ---------- Links (thin, robust, 0 = link to all) ----------
      const links = [];
      function addLinkByIds(srcId, tgtId){
        if(!srcId || !tgtId) return;
        if(String(srcId) === String(tgtId)) return;
        const srcNode = ensureNodeForId(srcId);
        const tgtNode = ensureNodeForId(tgtId);
        links.push({ source: srcNode, target: tgtNode, color:'#FFFFFF', width:1.2 });
      }
      rows.forEach(r=>{
        const srcRaw = String(r[col.id] ?? '').trim();
        if(!srcRaw) return;
        const seq = splitIdsFlexible(r[col.sequels]);
        const coln = splitIdsFlexible(r[col.collision]);
        const targets = [...seq, ...coln];
        if (targets.includes(0)) {
          nodes.forEach(n => { if (String(n.id) !== srcRaw) addLinkByIds(srcRaw, n.id); });
        } else {
          targets.forEach(num=>{
            if (num === 0) return;
            const tgt = nodeByNum.get(num) || nodeById.get(String(num)) || ensureNodeForId(num);
            addLinkByIds(srcRaw, tgt.id);
          });
        }
      });

      // --------- Build Graph ---------
      const elem = document.getElementById('g');
      let hoveredNode=null, pulseRAF=null;

      const Graph = ForceGraph3D()(elem)
        .enablePointerInteraction(true)
        .graphData({ nodes, links })
        .backgroundColor('#000014')
        .showNavInfo(false)
        .d3Force('link', null)
        .d3Force('charge', null)
        .enableNodeDrag(false)   // disabled as requested
        .cooldownTicks(0)
        .nodeThreeObject(n => {
          const colorHex = n.color || '#FF1447';
          const color = new THREE.Color(colorHex);
          const baseRadius=5;

          const core = new THREE.Mesh(
            new THREE.SphereGeometry(baseRadius,24,24),
            new THREE.MeshStandardMaterial({ color, metalness:0.12, roughness:0.38 })
          );

          const size = Math.max(1, Math.min(30, n.val || 5));
          const s = (size / 10) * 3.0;
          core.scale.set(s,s,s);

          // Idle glow: smaller
          const glow=makeGlowSprite(colorHex);
          const idleSize = baseRadius*s*5;
          glow.scale.set(idleSize,idleSize,1);
          glow.material.opacity = 0.24;
          core.add(glow);

          // only sphere is interactive
          core.raycast = THREE.Mesh.prototype.raycast;
          glow.raycast = () => null;

          n.__core=core; n.__glow=glow; n.__sizeScale=s; n.__idleSize=idleSize; n.__idleOpacity=0.24;
          return core;
        })
        .nodeLabel(n => {
          const color = n.color || '#FF1447';
          const hint = n.url ? '<span class="hint">Click to open archive</span>' : '<span class="hint">URL: N/A</span>';
          const cl = n.cluster ? `<br><span style="opacity:.9; font-size: 16px">Universe cluster: ${escapeHtml(n.cluster)}</span>` : '';
          return `<div class="poppy-label"><b style="color:${color}">${escapeHtml(n.label || n.id)}</b>${cl}<br>${hint}</div>`;
        })
        .linkColor(l => l.color || '#FFFFFF')
        .linkWidth(l => l.width || 0.9)
        .linkOpacity(0.75);

      // Lights
      const scene=Graph.scene();
      scene.add(new THREE.AmbientLight(0xffffff,0.38));
      const dir=new THREE.DirectionalLight(0xffffff,0.7); dir.position.set(60,80,40); scene.add(dir);

      // Controls
      const controls=Graph.controls();
      controls.enableRotate = true;
      controls.enablePan = true;
      controls.minDistance = 20;
      controls.maxDistance = 1200;
      controls.mouseButtons = {
        LEFT: THREE.MOUSE.ROTATE,
        MIDDLE: THREE.MOUSE.DOLLY,
        RIGHT: THREE.MOUSE.PAN
      };
      controls.update();

      // Hover pulse: tinted, subtle
      function pulse(){
        if(!hoveredNode || !hoveredNode.__glow || !hoveredNode.__core){ pulseRAF=requestAnimationFrame(pulse); return; }
        const t=(Date.now()%1200)/1200;
        const amp = 1 + 0.12 * Math.sin(t * Math.PI * 2);
        const opacity = 0.34 + 0.22 * (0.5 + 0.5 * Math.sin(t * 2*Math.PI));
        const b=hoveredNode.__sizeScale;
        hoveredNode.__core.scale.set(b*1.04,b*1.04,b*1.04);
        const big = hoveredNode.__idleSize * 1.35;
        hoveredNode.__glow.scale.set(big*amp, big*amp, 1);
        hoveredNode.__glow.material.opacity = opacity;
        pulseRAF=requestAnimationFrame(pulse);
      }

      Graph
        .onNodeHover((node, prev)=>{
          if(prev && prev.__core && prev.__glow){
            const b=prev.__sizeScale;
            prev.__core.scale.set(b,b,b);
            prev.__glow.scale.set(prev.__idleSize, prev.__idleSize, 1);
            prev.__glow.material.opacity = prev.__idleOpacity;
          }
          hoveredNode=node||null;
          if(hoveredNode){
            elem.style.cursor='pointer';
            if(!pulseRAF) pulseRAF=requestAnimationFrame(pulse);
          } else {
            elem.style.cursor=null;
            if(pulseRAF){ cancelAnimationFrame(pulseRAF); pulseRAF=null; }
          }
        })
        .onNodeClick(n=>{ if(n.url) window.open(n.url,'_blank','noopener'); });

      // -------- Center camera + add positive-only white axes --------
      fitCameraAndAxes(nodes);

      function fitCameraAndAxes(list){
        if (!list.length) return;
        let minX=Infinity,minY=Infinity,minZ=Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;
        for(const n of list){
          if(n.x<minX)minX=n.x; if(n.y<minY)minY=n.y; if(n.z<minZ)minZ=n.z;
          if(n.x>maxX)maxX=n.x; if(n.y>maxY)maxY=n.y; if(n.z>maxZ)maxZ=n.z;
        }
        // origin at minima (positive-only axes)
        const ox=minX, oy=minY, oz=minZ;
        const spanX=maxX-minX, spanY=maxY-minY, spanZ=maxZ-minZ;
        const span = Math.max(spanX, spanY, spanZ);
        const dist = span * 1.1 + 800; // tighter camera distance for compact space

        const cx = ox + spanX/2, cy = oy + spanY/2, cz = oz + spanZ/2;

        controls.target.set(cx, cy, cz);
        controls.update();

        Graph.cameraPosition(
          { x: cx + dist, y: cy + dist, z: cz + dist },
          { x: cx,       y: cy,       z: cz       },
          0
        );

        addAxesPositive(scene, {x:ox,y:oy,z:oz}, {x:spanX, y:spanY, z:spanZ});
      }

      // --- Build legend (reuse clusterOrder & clusterColor) ---
      rowsEl.innerHTML = '';
      clusterOrder.forEach(tag => {
        const color = clusterColor[tag];
        const row = document.createElement('div');
        row.className = 'row';

        const sw = document.createElement('div');
        sw.className = 'swatch';
        sw.style.background = color;
        sw.style.boxShadow = `0 0 12px ${color}`;

        const la = document.createElement('div');
        la.className = 'label';
        la.textContent = tag;

        row.appendChild(sw);
        row.appendChild(la);
        rowsEl.appendChild(row);
      });
      legendEl.hidden = false;
      toggleEl.addEventListener('click', () => {
        legendEl.classList.toggle('collapsed');
        const chevron = legendEl.querySelector('.toggle');
        chevron.textContent = legendEl.classList.contains('collapsed') ? '▸' : '▾';
      });

    })
    .catch(err => {
      document.body.innerHTML = '<pre style="color:#fff; padding:16px">'+String(err)+'</pre>';
      console.error(err);
    });

  // ---- Glow helpers (defined once) ----
  const glowTexCache={};
  function makeGlowTexture(hex){
    if(glowTexCache[hex]) return glowTexCache[hex];
    const {r,g,b}=hexToRgb(hex); const size=256;
    const canvas=document.createElement('canvas'); canvas.width=canvas.height=size;
    const ctx=canvas.getContext('2d');
    const grd=ctx.createRadialGradient(size/2,size/2,size*0.06,size/2,size/2,size*0.5);
    grd.addColorStop(0.00,'rgba(255,255,255,0.85)');
    grd.addColorStop(0.18,`rgba(${r},${g},${b},0.38)`);
    grd.addColorStop(0.60,`rgba(${r},${g},${b},0.14)`);
    grd.addColorStop(1.00,'rgba(0,0,0,0)');
    ctx.fillStyle=grd; ctx.fillRect(0,0,size,size);
    const tex=new THREE.CanvasTexture(canvas); tex.needsUpdate=true; glowTexCache[hex]=tex; return tex;
  }
  function makeGlowSprite(hex){
    const map=makeGlowTexture(hex);
    const mat=new THREE.SpriteMaterial({
      map, color:0xffffff, transparent:true, depthWrite:false,
      blending:THREE.AdditiveBlending, opacity:0.24
    });
    const spr=new THREE.Sprite(mat);
    spr.raycast = () => null; // glow never catches clicks
    return spr;
  }

  // ---- Axis helpers (positive-only, white) ----
  function addAxesPositive(scene, origin, spans){
    // remove old axes if present
    const old = scene.getObjectByName('axesGroup');
    if (old) scene.remove(old);

    const g = new THREE.Group();
    g.name = 'axesGroup';
    g.raycast = () => null;

    const lineMat = new THREE.LineBasicMaterial({ color: 0x00FFFF, transparent:true, opacity:0.9 });

    // Lines from origin → positive ends
    const xGeo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(origin.x, origin.y, origin.z),
      new THREE.Vector3(origin.x + spans.x, origin.y, origin.z)
    ]);
    const yGeo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(origin.x, origin.y, origin.z),
      new THREE.Vector3(origin.x, origin.y + spans.y, origin.z)
    ]);
    const zGeo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(origin.x, origin.y, origin.z),
      new THREE.Vector3(origin.x, origin.y, origin.z + spans.z)
    ]);
    const xAxis = new THREE.Line(xGeo, lineMat); xAxis.raycast = () => null;
    const yAxis = new THREE.Line(yGeo, lineMat); yAxis.raycast = () => null;
    const zAxis = new THREE.Line(zGeo, lineMat); zAxis.raycast = () => null;

    // Arrow tips
    const tipGeom = new THREE.ConeGeometry(12, 38, 16);
    const tipMat = new THREE.MeshBasicMaterial({ color: 0x00FFFF });
    const xTip = new THREE.Mesh(tipGeom, tipMat); xTip.position.set(origin.x + spans.x, origin.y, origin.z); xTip.rotation.z = -Math.PI / 2;
    const yTip = new THREE.Mesh(tipGeom, tipMat); yTip.position.set(origin.x, origin.y + spans.y, origin.z); yTip.rotation.x =  Math.PI / 2;
    const zTip = new THREE.Mesh(tipGeom, tipMat); zTip.position.set(origin.x, origin.y, origin.z + spans.z);
    [xTip,yTip,zTip].forEach(m=>{ m.raycast=()=>null; m.renderOrder=1; });

    // Labels
    const xLabel = makeTextSprite(AXIS_NAMES.x, '#00FFFF');
    const yLabel = makeTextSprite(AXIS_NAMES.y, '#00FFFF');
    const zLabel = makeTextSprite(AXIS_NAMES.z, '#00FFFF');
    const lblOff = 68;
    xLabel.position.set(origin.x + spans.x + lblOff, origin.y, origin.z);
    yLabel.position.set(origin.x, origin.y + spans.y + lblOff, origin.z);
    zLabel.position.set(origin.x, origin.y, origin.z + spans.z + lblOff);
    [xLabel,yLabel,zLabel].forEach(s=>{ s.raycast=()=>null; s.renderOrder=2; });

    g.add(xAxis,yAxis,zAxis,xTip,yTip,zTip,xLabel,yLabel,zLabel);
    scene.add(g);
  }

  function makeTextSprite(text, color='#FFFFFF'){
    const fontSize = 15;
    const pad = 8;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    ctx.font = `bold ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
    const metrics = ctx.measureText(text);
    const w = Math.ceil(metrics.width) + pad*2;
    const h = Math.ceil(fontSize*1.6) + pad*2;
    canvas.width = w;
    canvas.height = h;

    const ctx2 = canvas.getContext('2d');
    ctx2.font = `bold ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
    ctx2.textAlign = 'center';
    ctx2.textBaseline = 'middle';

    // neutral white frame
    ctx2.fillStyle = 'rgba(0,0,0,0.35)';
    ctx2.strokeStyle = 'rgba(0,255,255,0.45)';
    ctx2.lineWidth = 2;
    roundRect(ctx2, 1,1, w-2,h-2, 12); ctx2.fill(); ctx2.stroke();

    ctx2.fillStyle = color;
    ctx2.shadowColor = color;
    ctx2.shadowBlur = 10;
    ctx2.fillText(text, w/2, h/2);

    const tex = new THREE.CanvasTexture(canvas);
    tex.minFilter = THREE.LinearFilter;
    tex.needsUpdate = true;

    const mat = new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false });
    const spr = new THREE.Sprite(mat);
    const scale = 80;
    spr.scale.set(scale*(w/h), scale, 1);
    return spr;
  }

  function roundRect(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y,   x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x,   y+h, rr);
    ctx.arcTo(x,   y+h, x,   y,   rr);
    ctx.arcTo(x,   y,   x+w, y,   rr);
    ctx.closePath();
  }
  </script>
</body>
</html>
