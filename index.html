<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Into the Poppyverse - A Multiversal Story Map</title>
  <link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><text y="50%" x="50%" dominant-baseline="middle" text-anchor="middle" font-size="52">ðŸŒ·</text></svg>'>

  <style>
    html, body { margin:0; height:100%; background:#0b0b12; overflow:hidden; }
    :root {
      --poppy-red: #FF1447;
      --chart-color: #fff;
    }

    /* --- starry background layer (fades in smoothly) --- */
    #bg{
      position: fixed; inset: 0; z-index: 0;
      background-position: center center;
      background-repeat: no-repeat;
      background-size: cover;
      background-attachment: fixed;
      opacity: 0;
      transform: scale(1.04);
      transition:
        opacity 1200ms ease,
        transform 3200ms cubic-bezier(.22,.61,.36,1);
      filter: saturate(1.05) contrast(1.06) brightness(.92);
    }
    #bg.show{ opacity: 1; transform: scale(1); }

    /* graph container sits above the bg */
    #g { position: relative; z-index: 1; width:100vw; height:100vh; }

    /* legend: starts collapsed because we respect your attention span */
    #legend {
      position: fixed; top: 14px; left: 14px; z-index: 10;
      background: rgba(0,0,0,.4);
      border: 1px solid rgba(255,255,255,.4);
      border-radius: 12px;
      padding: 10px 12px 12px 12px;
      color: #fff;
      font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      max-width: 33vw; backdrop-filter: blur(4px);
      pointer-events: auto; user-select: none;
    }
    #legend header { display:flex; align-items:center; justify-content:space-between; gap:10px; cursor:pointer; padding:4px 2px; }
    #legend h3 { margin:0; font-size:18px; letter-spacing:.02em; opacity:.97; }
    #legend .toggle {
      width:26px; height:26px; border-radius:8px;
      border:1px solid rgba(255,255,255,.25);
      display:flex; align-items:center; justify-content:center;
      font-size:16px; line-height:1; opacity:.9;
    }
    #legend .rows { margin-top:8px; }
    #legend .row { display:flex; align-items:center; gap:12px; margin:8px 0; }
    #legend .swatch { width:18px; height:18px; border-radius:5px; border:1px solid rgba(255,255,255,.28); box-shadow:0 0 12px rgba(255,255,255,.18); }
    #legend .label { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:38vw; opacity:.95; }
    #legend.collapsed .rows { display:none; }
    #legend.collapsed .toggle { opacity:.7; }
    #legend .static-link { margin-top:12px; font-size:14px; opacity:.95; }
    #legend .static-link a { color:var(--poppy-red); text-decoration:none; border-bottom:1px dashed var(--poppy-red); }
    #legend .static-link a:hover { text-decoration:underline; }

    /* tooltip layout â€” clearer key/value vibes */
    .poppy-label .title {
      display:block; font-weight:800; letter-spacing:.01em;
      text-shadow:0 0 12px currentColor, 0 0 28px currentColor;
      margin-bottom:4px;
    }
    .poppy-label .kv { display:block; font-size:16px; line-height:1.45; margin:2px 0; }
    .poppy-label .kv .key {
      opacity:.75; text-transform:uppercase; letter-spacing:.06em;
      font-size:13px; margin-right:6px;
    }
    .poppy-label .kv .val { font-weight:600; opacity:.98; }
    .poppy-label .kv.cluster .val { text-shadow:0 0 10px currentColor; }
    .poppy-label .sep {
      display:block; height:1px; margin:6px 0 4px 0;
      background:linear-gradient(90deg, rgba(255,255,255,.22), rgba(255,255,255,.06) 60%, rgba(255,255,255,0));
    }
  </style>
</head>
<body>
  <div id="bg"></div>
  <div id="g"></div>

  <!-- yes, itâ€™s collapsed by default; curiosity optional -->
  <div id="legend" class="collapsed" hidden>
    <header id="legend-toggle">
      <h3>Universe clusters by color key</h3>
      <div class="toggle" aria-label="Toggle legend" title="Toggle legend">â–¸</div>
    </header>
    <div class="rows" id="legend-rows"></div>
    <div class="static-link">
      Prefer a calmer, saner static index? See the <a href="https://inpoppyfields.tumblr.com/map" target="_blank" rel="noopener">Story Map</a>.
    </div>
  </div>

  <!-- libs -->
  <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/3d-force-graph"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
  //#region csv setup
  const CSV_CANDIDATES = [
    'table.csv',
    'table - export.csv',
    'table (export).csv',
    'the poppy board.csv',
    'the poppy board v2.csv',
    'the poppy board, v2 28b95a1c19ee80249fb2fd23fc0b9532.csv'
  ];
  async function fetchFirstCsv() {
    for (const name of CSV_CANDIDATES) {
      try {
        const res = await fetch(name, { cache: 'no-cache' });
        if (res.ok) return await res.text();
      } catch {}
    }
    throw new Error('csv not found. add your filename to CSV_CANDIDATES (must contain "table" or "the poppy board").');
  }
  //#endregion

  //#region columns, palette, helpers
  const COLNAMES = {
    id: ['id','node id','uid','slug'],
    name: ['name','title','label'],
    tags: ['tag','tags','category','categories'],
    size: ['size','val','value','weight'],
    content: ['content'],
    meta: ['meta'],
    relatable: ['relatable'],
    sequels: ['sequels','sequel','next','edges','to'],
    collision: ['collision','collisions','collide','also to'],
    url: ['url','link','href','permalink']
  };

  const TAG_PALETTE = ['#FF1447','#FF2E7A','#FF5AC8','#C243FF','#8A3DFF','#4F6CFF','#1CC6FF','#00E5FF'];

  const AXES_COLOR = 0xFF1447;
  const AXES_COLOR_STRING = '#FF1447';

  const POS_SCALE = 100, CLUSTER_BASE=28, CLUSTER_STEP=20, RANDOM_RADIAL=26, BASE_JITTER=100, EXTRA_JITTER=26;

  const AXIS_NAMES = {
    x: 'Lumen Inversion',
    y: 'Metaphysical Drift',
    z: 'Proximity to Home'
  };

  function lerp(a,b,t){ return a + (b-a)*t; }
  function hexToRgb(hex){ const s=String(hex).replace('#',''); return { r:parseInt(s.slice(0,2),16), g:parseInt(s.slice(2,4),16), b:parseInt(s.slice(4,6),16) }; }
  function rgbToHex(r,g,b){ const h=v=>v.toString(16).padStart(2,'0'); return '#'+h(r)+h(g)+h(b); }
  function extendCool(i){ const a=hexToRgb(TAG_PALETTE[TAG_PALETTE.length-2]), b=hexToRgb(TAG_PALETTE[TAG_PALETTE.length-1]); const t=(i%6)/6; return rgbToHex(Math.round(lerp(a.r,b.r,t)),Math.round(lerp(a.g,b.g,t)),Math.round(lerp(a.b,b.b,t))); }

  function normalizeHeaders(fields){ const map={}; (fields||[]).forEach(f=>map[String(f||'').trim().toLowerCase()]=f); return map; }
  function pick(headers, aliases){
    for (const a of aliases){
      const k=a.toLowerCase();
      if (k in headers) return headers[k];
      for (const key in headers){ if (key.includes(k)) return headers[key]; }
    }
    return null;
  }
  function splitIdsFlexible(s){
    if (s==null) return [];
    const raw=String(s).trim(); if (!raw) return [];
    return raw.split(/[\s,;|]+/).map(t=>t.trim()).filter(Boolean).map(t=>Number(t)).filter(n=>Number.isFinite(n));
  }
  function parseParenNumber(s, fb=null){ const m=/\(\s*([-+]?\d*\.?\d+)\s*\)/.exec(String(s||'')); return m?Number(m[1]):fb; }
  function toSize(s){ const fromParen=parseParenNumber(s); const n=(fromParen!=null)?fromParen:((s==null||s==='')?5:Number(s)); const v=Number.isFinite(n)?n:5; return Math.max(1, Math.min(30, v)); }
  function escapeHtml(s){ const map={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}; return String(s||'').replace(/[&<>"']/g,c=>map[c]); }
  function hash32(str){ let h=2166136261>>>0; for (let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=Math.imul(h,1677619);} return h>>>0; }
  function rand(seed){ seed=(seed+0x6D2B79F5)>>>0; let t=Math.imul(seed^(seed>>>15),1|seed); t=(t+Math.imul(t^(t>>>7),61|t))^t; return ((t^(t>>>14))>>>0)/4294967296; }

  function describeMeta(v){ if (v==null) return '???'; if (v<=1) return 'grounded'; if (v<=2) return 'a bit wobbly'; if (v<=3) return 'glitch-prone'; if (v<=4) return 'esoteric'; return 'full transcendence'; }
  function describeLumen(v){ if (v==null) return '???'; if (v<=1) return 'daylight-adjacent'; if (v<=2) return 'bring a dimmer'; if (v<=3) return 'bring a flashlight'; if (v<=4) return 'pitchy'; return 'void-certified'; }
  function describeHome(v){ if (v==null) return '???'; if (v<=1) return 'far-out'; if (v<=2) return 'road-trip distance'; if (v<=3) return 'local-ish'; if (v<=4) return 'next-door energy'; return 'inside your kitchen'; }
  //#endregion

  //#region data load â†’ nodes â†’ links
  fetchFirstCsv()
    .then(txt => new Promise(resolve => {
      Papa.parse(txt, { header:true, dynamicTyping:false, skipEmptyLines:true, complete: resolve });
    }))
    .then(result => {
      const rows = result.data || [];
      if (!rows.length) throw new Error('csv has no rows');

      const headers = normalizeHeaders(result.meta.fields || Object.keys(rows[0] || {}));
      const col = {
        id: pick(headers, COLNAMES.id) || pick(headers, COLNAMES.name),
        name: pick(headers, COLNAMES.name),
        tags: pick(headers, COLNAMES.tags),
        size: pick(headers, COLNAMES.size),
        content: pick(headers, COLNAMES.content),
        meta: pick(headers, COLNAMES.meta),
        relatable: pick(headers, COLNAMES.relatable),
        sequels: pick(headers, COLNAMES.sequels),
        collision: pick(headers, COLNAMES.collision),
        url: pick(headers, COLNAMES.url)
      };
      if (!col.id || !col.tags) throw new Error('need at least id/name and tag columns');

      const nodeBuckets = Object.create(null);

      const nodes = rows.map(r => {
        const id = String(r[col.id] ?? '').trim();
        const label = String(r[col.name] ?? id).trim() || id;
        const cluster = String(r[col.tags] ?? '').trim() || '(unclustered)';
        if (!id || !cluster) return null;

        const url = ((r[col.url] ?? '') + '').trim() || null;
        const size = toSize(r[col.size]);

        const xv = parseParenNumber(r[col.content], 0);
        const yv = parseParenNumber(r[col.meta], 0);
        const zv = parseParenNumber(r[col.relatable], 0);

        const qMeta  = describeMeta(yv);
        const qLumen = describeLumen(xv);
        const qHome  = describeHome(zv);

        const TX = (Number.isFinite(xv) ? xv : 0) * POS_SCALE;
        const TY = (Number.isFinite(yv) ? yv : 0) * POS_SCALE;
        const TZ = (Number.isFinite(zv) ? zv : 0) * POS_SCALE;

        const bucketKey = `${xv}|${yv}|${zv}`;
        nodeBuckets[bucketKey] = (nodeBuckets[bucketKey] || 0);
        const idx = nodeBuckets[bucketKey]++;

        const seed = hash32(id + '|' + bucketKey);
        const r1 = rand(seed), r2 = rand(seed+1), r3 = rand(seed+2), r4 = rand(seed+3);

        const PHI = 2.399963229728653;
        const baseRadius = CLUSTER_BASE + CLUSTER_STEP * Math.sqrt(idx);
        const radius = baseRadius + (r1 - 0.5) * 2 * RANDOM_RADIAL;
        const angle  = idx * PHI + r2 * Math.PI * 2;

        const jAmp = BASE_JITTER + r3 * EXTRA_JITTER;
        const jx = (r4 * 2 - 1) * jAmp;
        const jy = (rand(seed + 4) * 2 - 1) * jAmp;
        const jz = (rand(seed + 5) * 2 - 1) * jAmp;

        const dx = radius * Math.cos(angle) + jx;
        const dy = radius * Math.sin(angle) + jy;
        const dz = jz;

        const x = TX + dx, y = TY + dy, z = TZ + dz;

        return {
          id, label, cluster, url,
          val: size,
          x,y,z, fx:x,fy:y,fz:z, tx:x,ty:y,tz:z,
          color: null,
          _axes: { xv,yv,zv },
          _q: { meta: qMeta, lumen: qLumen, home: qHome },
          _dbg: { seed, idx, baseRadius, radius, angle, jx, jy, jz, TX, TY, TZ }
        };
      }).filter(Boolean);

      const nodeById = new Map(), nodeByNum = new Map();
      nodes.forEach(n => {
        nodeById.set(String(n.id), n);
        const num = Number(n.id);
        if (Number.isFinite(num)) nodeByNum.set(num, n);
      });

      const clusterOrder = [], seen = new Set(), clusterColor = {};
      nodes.forEach(n => { if (!seen.has(n.cluster)) { seen.add(n.cluster); clusterOrder.push(n.cluster); }});
      clusterOrder.forEach((t,i) => clusterColor[t] = (i < TAG_PALETTE.length) ? TAG_PALETTE[i] : extendCool(i - TAG_PALETTE.length));
      nodes.forEach(n => n.color = clusterColor[n.cluster]);

      function ensureNodeForId(raw){
        const key = String(raw);
        let node = nodeById.get(key);
        if (node) return node;
        node = { id:key, label:key, cluster:'(referenced)', url:null, val:5, x:0,y:0,z:0, fx:0,fy:0,fz:0, tx:0,ty:0,tz:0, color:'#00E5FF', _dbg:{seed:0} };
        nodes.push(node); nodeById.set(key,node);
        const num = Number(key); if (Number.isFinite(num)) nodeByNum.set(num,node);
        return node;
      }

      const links = [];
      function addLinkByIds(srcId, tgtId){
        if (!srcId || !tgtId) return;
        if (String(srcId) === String(tgtId)) return;
        const srcNode = ensureNodeForId(srcId);
        const tgtNode = ensureNodeForId(tgtId);
        links.push({ source: srcNode, target: tgtNode, color:'#FFFFFF', width:0.7 });
      }

      rows.forEach(r => {
        const srcRaw = String(r[col.id] ?? '').trim(); if (!srcRaw) return;
        const seq = splitIdsFlexible(r[col.sequels]);
        const coln= splitIdsFlexible(r[col.collision]);
        const targets = [...seq, ...coln];
        if (targets.includes(0)) {
          nodes.forEach(n => { if (String(n.id) !== srcRaw) addLinkByIds(srcRaw, n.id); });
        } else {
          targets.forEach(num => { if (num===0) return; const tgt=nodeByNum.get(num)||nodeById.get(String(num))||ensureNodeForId(num); addLinkByIds(srcRaw, tgt.id); });
        }
      });

      //#endregion

      //#region graph build (transparent renderer + bg)
      const elem = document.getElementById('g');
      let hoveredNode = null, pulseRAF = null;

      const Graph = ForceGraph3D()(elem)
        .enablePointerInteraction(true)
        .graphData({ nodes, links })
        .showNavInfo(false)
        .d3Force('link', null)
        .d3Force('charge', null)
        .enableNodeDrag(false)
        .cooldownTicks(0)
        .nodeThreeObject(n => {
          const colorHex = n.color || '#FF1447';
          const color = new THREE.Color(colorHex);
          const baseRadius = 5;

          const core = new THREE.Mesh(
            new THREE.SphereGeometry(baseRadius, 24, 24),
            new THREE.MeshStandardMaterial({ color, metalness: 0.12, roughness: 0.38 })
          );

          const size = Math.max(5, Math.min(30, n.val || 5));
          const s = (size / 5);
          core.scale.set(s, s, s);

          // idle glow â€” ensure minimum pixel size so tiny nodes still pop
          const glow = makeGlowSprite(colorHex);
          const idleSize = Math.max(18, baseRadius * s * 3); // â¬… bigger floor for small nodes
          glow.scale.set(idleSize, idleSize, 1);
          glow.material.opacity = 0.55;
          core.add(glow);

          core.raycast = THREE.Mesh.prototype.raycast;
          glow.raycast = () => null;

          n.__core = core;
          n.__glow = glow;
          n.__sizeScale = s;
          n.__idleSize = idleSize;
          n.__idleOpacity = 0.35; // a touch brighter idle

          return core;
        })
        .nodeLabel(n => {
          const color = n.color || '#FF1447';
          const meta  = n._q?.meta  ?? 'â€”';
          const lumen = n._q?.lumen ?? 'â€”';
          const home  = n._q?.home  ?? 'â€”';
          const hint = n.url ? '<span class="hint">Click to open archive</span>' : '<span class="hint">URL: N/A</span>';
          return `
            <div class="poppy-label">
              <span class="title" style="color:${color}">${escapeHtml(n.label || n.id)}</span>
              <span class="kv cluster"><span class="key">Cluster</span><span class="val" style="color:${color}">${escapeHtml(n.cluster || '(unclustered)')}</span></span>
              <span class="sep"></span>
              <span class="kv"><span class="key">Lumen</span><span class="val">${escapeHtml(lumen)}</span></span>
              <span class="kv"><span class="key">Meta</span><span class="val">${escapeHtml(meta)}</span></span>
              <span class="kv"><span class="key">Home</span><span class="val">${escapeHtml(home)}</span></span>
              <span class="sep"></span>
              ${hint}
            </div>`;
        })
        .linkColor(l => l.color || '#FFFFFF')
        .linkWidth(l => l.width || 0.9)
        .linkOpacity(0.75);

      // Transparent renderer so CSS bg shows through
      // --- Transparent renderer that actually renders :)
const w = window.innerWidth;
const h = window.innerHeight;

const transparentRenderer = new THREE.WebGLRenderer({
  antialias: true,
  alpha: true,
  powerPreference: 'high-performance',
  preserveDrawingBuffer: false
});
transparentRenderer.setPixelRatio(window.devicePixelRatio || 1);
transparentRenderer.setSize(w, h);
transparentRenderer.setClearColor(0x000000, 0);
transparentRenderer.setClearAlpha(0);
transparentRenderer.outputColorSpace = THREE.SRGBColorSpace;
transparentRenderer.toneMapping = THREE.ACESFilmicToneMapping;
transparentRenderer.toneMappingExposure = 1.05;

// hand to the graph BEFORE we query scene/camera
Graph.renderer(transparentRenderer);

// make sure the canvas is in the DOM (FG usually does this, we ensure it)
if (!transparentRenderer.domElement.parentNode) {
  elem.appendChild(transparentRenderer.domElement);
}

// force graph to know its width/height (critical with custom renderer)
Graph.width(w).height(h);

// fully transparent background (donâ€™t pass null)
Graph.backgroundColor('rgba(0,0,0,0)');

// now safe to tweak scene
const scene = Graph.scene();
scene.background = null;

// keep everything sized correctly on resize
window.addEventListener('resize', () => {
  const W = window.innerWidth;
  const H = window.innerHeight;

  transparentRenderer.setSize(W, H);
  const cam = Graph.camera();
  cam.aspect = W / H;
  cam.updateProjectionMatrix();

  Graph.width(W).height(H);
  Graph.refresh(); // ensure a redraw
});
      

      // controls
      const controls = Graph.controls();
      controls.enableRotate = true;
      controls.enablePan = true;
      controls.minDistance = 20;
      controls.maxDistance = 1200;
      controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
      controls.update();

      // keep renderer sized
      window.addEventListener('resize', () => {
        const w = elem.clientWidth, h = elem.clientHeight;
        transparentRenderer.setSize(w, h);
      });

      // hover pulse â€” slightly larger swing so small nodes are obvious
      function pulse() {
        if (!hoveredNode || !hoveredNode.__glow || !hoveredNode.__core) {
          pulseRAF = requestAnimationFrame(pulse);
          return;
        }
        const t = (Date.now() % 1200) / 1200;
        const amp = 1 + 0.14 * Math.sin(t * Math.PI * 2);
        const opacity = 0.48 + 0.28 * (0.5 + 0.5 * Math.sin(t * 2 * Math.PI));

        const b = hoveredNode.__sizeScale;
        hoveredNode.__core.scale.set(b * 1.045, b * 1.045, b * 1.045);

        const big = Math.max(hoveredNode.__idleSize * 1.35, 28); // â¬… ensure visible size
        hoveredNode.__glow.scale.set(big * amp, big * amp, 1);
        hoveredNode.__glow.material.opacity = opacity;

        pulseRAF = requestAnimationFrame(pulse);
      }

      Graph
        .onNodeHover((node, prev) => {
          if (prev && prev.__core && prev.__glow) {
            const b = prev.__sizeScale;
            prev.__core.scale.set(b, b, b);
            prev.__glow.scale.set(prev.__idleSize, prev.__idleSize, 1);
            prev.__glow.material.opacity = prev.__idleOpacity;
          }
          hoveredNode = node || null;
          if (hoveredNode) {
            elem.style.cursor = 'pointer';
            if (!pulseRAF) pulseRAF = requestAnimationFrame(pulse);
          } else {
            elem.style.cursor = null;
            if (pulseRAF) { cancelAnimationFrame(pulseRAF); pulseRAF = null; }
          }
        })
        .onNodeClick(n => { if (n.url) window.open(n.url, '_blank', 'noopener'); });

      //#endregion

      //#region camera + axes + origin
      fitCameraAndAxes(nodes);

      function fitCameraAndAxes(list) {
        if (!list.length) return;

        let minX=Infinity, minY=Infinity, minZ=Infinity, maxX=-Infinity, maxY=-Infinity, maxZ=-Infinity;
        for (const n of list) {
          if (n.x < minX) minX = n.x; if (n.y < minY) minY = n.y; if (n.z < minZ) minZ = n.z;
          if (n.x > maxX) maxX = n.x; if (n.y > maxY) maxY = n.y; if (n.z > maxZ) maxZ = n.z;
        }

        // axes with positive-only span (origin at minima)
        const ox=minX, oy=minY, oz=minZ;
        const spanX = maxX - minX, spanY = maxY - minY, spanZ = maxZ - minZ;
        const span = Math.max(spanX, spanY, spanZ);

        const dist = span * 0.7, yOffset = 50;
        const cx = ox + spanX/2, cy = oy + spanY/2, cz = oz + spanZ/2;

        controls.target.set(cx, cy, cz);
        controls.update();

        Graph.cameraPosition(
          { x: cx + dist, y: cy + dist + yOffset, z: cz + dist },
          { x: cx,        y: cy + yOffset,        z: cz       },
          0
        );

        addAxesPositive(scene, { x: ox, y: oy, z: oz }, { x: spanX, y: spanY, z: spanZ });

        // add absolute origin marker at (0,0,0) independent of the dataset bounds
        addOriginMarker(scene, { x:0, y:0, z:0 });
      }
      //#endregion

      //#region legend
      const legendEl = document.getElementById('legend');
      const rowsEl   = document.getElementById('legend-rows');
      const toggleEl = document.getElementById('legend-toggle');

      rowsEl.innerHTML = '';
      clusterOrder.forEach(tag => {
        const color = clusterColor[tag];
        const row = document.createElement('div'); row.className='row';
        const sw = document.createElement('div'); sw.className='swatch'; sw.style.background=color; sw.style.boxShadow=`0 0 12px ${color}`;
        const la = document.createElement('div'); la.className='label'; la.textContent=tag;
        row.appendChild(sw); row.appendChild(la); rowsEl.appendChild(row);
      });
      legendEl.hidden = false;
      toggleEl.addEventListener('click', () => {
        legendEl.classList.toggle('collapsed');
        const chevron = legendEl.querySelector('.toggle');
        chevron.textContent = legendEl.classList.contains('collapsed') ? 'â–¸' : 'â–¾';
      });
      //#endregion

      // finally, fade in the wallpaper behind our now-transparent canvas
      fadeInGalaxyBackground('https://images.unsplash.com/photo-1648563643923-2091f9c0c12f?ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&q=80&w=2831');
    })
    .catch(err => {
      document.body.innerHTML = '<pre style="color:#fff; padding:16px">' + String(err) + '</pre>';
      console.error(err);
    });

  //#region background helper
  function fadeInGalaxyBackground(url){
    const el = document.getElementById('bg');
    if (!el) return;
    const img = new Image();
    img.onload = () => {
      el.style.backgroundImage = `url("${url}")`;
      requestAnimationFrame(() => el.classList.add('show'));
    };
    img.onerror = () => console.warn('Background failed to load:', url);
    img.src = url;
  }
  //#endregion

  //#region glow helpers
  const glowTexCache = {};
  function makeGlowTexture(hex){
    if (glowTexCache[hex]) return glowTexCache[hex];
    const { r,g,b } = hexToRgb(hex);
    const size = 256;
    const canvas = document.createElement('canvas'); canvas.width=size; canvas.height=size;
    const ctx = canvas.getContext('2d');
    const grd = ctx.createRadialGradient(size/2,size/2,size*0.05, size/2,size/2,size*0.42);
    grd.addColorStop(0.06, 'rgba(255,255,255,0.92)');
    grd.addColorStop(0.32, `rgba(${r},${g},${b},0.50)`);
    grd.addColorStop(0.62, `rgba(${r},${g},${b},0.18)`);
    grd.addColorStop(1.00, 'rgba(0,0,0,0)');
    ctx.fillStyle = grd; ctx.fillRect(0,0,size,size);
    const tex = new THREE.CanvasTexture(canvas); tex.needsUpdate = true;
    glowTexCache[hex] = tex; return tex;
  }
  function makeGlowSprite(hex){
    const map = makeGlowTexture(hex);
    const mat = new THREE.SpriteMaterial({ map, color:hex, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, opacity:0.7 });
    const spr = new THREE.Sprite(mat); spr.raycast = () => null; return spr;
  }
  //#endregion

  //#region axes + origin
  function addAxesPositive(scene, origin, spans){
    const old = scene.getObjectByName('axesGroup'); if (old) scene.remove(old);
    const g = new THREE.Group(); g.name='axesGroup'; g.raycast=()=>null;
    const lineMat = new THREE.LineBasicMaterial({ color: AXES_COLOR, transparent:true, opacity:1.0 });

    const xGeo = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(origin.x, origin.y, origin.z), new THREE.Vector3(origin.x + spans.x, origin.y, origin.z) ]);
    const yGeo = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(origin.x, origin.y, origin.z), new THREE.Vector3(origin.x, origin.y + spans.y, origin.z) ]);
    const zGeo = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(origin.x, origin.y, origin.z), new THREE.Vector3(origin.x, origin.y, origin.z + spans.z) ]);
    const xAxis = new THREE.Line(xGeo, lineMat), yAxis = new THREE.Line(yGeo, lineMat), zAxis = new THREE.Line(zGeo, lineMat);
    xAxis.raycast=()=>null; yAxis.raycast=()=>null; zAxis.raycast=()=>null;

    const xLabel = makeTextSprite(AXIS_NAMES.x, AXES_COLOR_STRING);
    const yLabel = makeTextSprite(AXIS_NAMES.y, AXES_COLOR_STRING);
    const zLabel = makeTextSprite(AXIS_NAMES.z, AXES_COLOR_STRING);
    const lblOff = 8;
    xLabel.position.set(origin.x + spans.x + lblOff, origin.y, origin.z);
    yLabel.position.set(origin.x, origin.y + spans.y + lblOff, origin.z);
    zLabel.position.set(origin.x, origin.y, origin.z + spans.z + lblOff);
    [xLabel, yLabel, zLabel].forEach(s => { s.raycast=()=>null; s.renderOrder=2; });

    g.add(xAxis, yAxis, zAxis, xLabel, yLabel, zLabel);
    scene.add(g);
  }

  function addOriginMarker(scene, origin){
    const old = scene.getObjectByName('originMarker'); if (old) scene.remove(old);
    const g = new THREE.Group(); g.name='originMarker'; g.raycast=()=>null;

    // tiny trihedra at (0,0,0)
    const len = 18;
    const mat = new THREE.LineBasicMaterial({ color: AXES_COLOR, transparent:true, opacity:0.9 });
    const gx = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(origin.x, origin.y, origin.z), new THREE.Vector3(origin.x+len, origin.y, origin.z) ]);
    const gy = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(origin.x, origin.y, origin.z), new THREE.Vector3(origin.x, origin.y+len, origin.z) ]);
    const gz = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(origin.x, origin.y, origin.z), new THREE.Vector3(origin.x, origin.y, origin.z+len) ]);
    g.add(new THREE.Line(gx, mat), new THREE.Line(gy, mat), new THREE.Line(gz, mat));

    // little glowing core at origin
    const core = new THREE.Mesh(
      new THREE.SphereGeometry(1.6, 20, 20),
      new THREE.MeshStandardMaterial({ color: AXES_COLOR_STRING, metalness: 0.1, roughness: 0.25, emissive: 0x882222, emissiveIntensity: 0.8 })
    );
    core.position.set(origin.x, origin.y, origin.z);
    const glow = makeGlowSprite(AXES_COLOR_STRING); glow.scale.set(22,22,1); glow.material.opacity = 0.55;
    core.add(glow);
    g.add(core);

    // label
    const label = makeTextSprite('Origin (0, 0, 0)', AXES_COLOR_STRING);
    label.position.set(origin.x + 2, origin.y + 2, origin.z);
    g.add(label);

    scene.add(g);
  }

  function makeTextSprite(text, color = '#FFFFFF'){
    const fontSize = 12, pad = 8;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = `bold ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
    const metrics = ctx.measureText(text);
    const w = Math.ceil(metrics.width) + pad*2, h = Math.ceil(fontSize*1.6) + pad*2;
    canvas.width=w; canvas.height=h;

    const ctx2 = canvas.getContext('2d');
    ctx2.font = `bold ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
    ctx2.textAlign='center'; ctx2.textBaseline='middle';
    ctx2.fillStyle='rgba(0,0,0,0.35)'; ctx2.strokeStyle=AXES_COLOR_STRING; ctx2.lineWidth=1;
    roundRect(ctx2,1,1,w-2,h-2,12); ctx2.fill(); ctx2.stroke();
    ctx2.fillStyle=color; ctx2.shadowColor=color; ctx2.shadowBlur=10; ctx2.fillText(text, w/2, h/2);

    const tex = new THREE.CanvasTexture(canvas); tex.minFilter = THREE.LinearFilter; tex.needsUpdate=true;
    const mat = new THREE.SpriteMaterial({ map:tex, transparent:true, depthWrite:false });
    const spr = new THREE.Sprite(mat); const scale = 40; spr.scale.set(scale * (w/h), scale, 1); return spr;
  }
  function roundRect(ctx,x,y,w,h,r){ const rr=Math.min(r,w/2,h/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y, x+w,y+h, rr); ctx.arcTo(x+w,y+h, x,y+h, rr); ctx.arcTo(x,y+h, x,y, rr); ctx.arcTo(x,y, x+w,y, rr); ctx.closePath(); }
  //#endregion
  </script>
</body>
</html>