<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Poppyverse Graph — Random Scatter, Collapsed Legend, 1–30 sizes</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0b12; overflow:hidden; }
    #g { width:100vw; height:100vh; }

    /* Legend overlay (collapsed by default) */
    #legend {
      position: fixed; top: 14px; left: 14px; z-index: 10;
      background: rgba(0,0,0,.58);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 12px;
      padding: 10px 12px 12px 12px;
      color: #fff;
      font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      max-width: 46vw; backdrop-filter: blur(4px);
      pointer-events: auto; user-select: none;
    }
    #legend header {
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      cursor: pointer; padding: 4px 2px;
    }
    #legend h3 { margin: 0; font-size: 18px; letter-spacing: .02em; opacity:.97; }
    #legend .toggle {
      width: 26px; height: 26px; border-radius: 8px;
      border: 1px solid rgba(255,255,255,.25);
      display:flex; align-items:center; justify-content:center;
      font-size: 16px; line-height: 1; opacity:.9;
    }
    #legend .rows { margin-top: 8px; }
    #legend .row { display:flex; align-items:center; gap:12px; margin: 8px 0; }
    #legend .swatch { width: 18px; height: 18px; border-radius: 5px; border:1px solid rgba(255,255,255,.28); box-shadow: 0 0 12px rgba(255,20,71,.18); }
    #legend .label { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 34vw; opacity:.95; }
    #legend.collapsed .rows { display:none; }
    #legend.collapsed .toggle { opacity: .7; }

    /* Tooltip */
    .poppy-label {
      color: #fff;
      font: 18px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    .poppy-label b { color: #FF1447; text-shadow: 0 0 10px #FF1447; }
    .poppy-label .hint { opacity:.9; font-size: 16px; }
  </style>
</head>
<body>
  <div id="g"></div>

  <!-- Collapsed by default -->
  <div id="legend" class="collapsed" hidden>
    <header id="legend-toggle">
      <h3>Universe clusters (color key)</h3>
      <div class="toggle" aria-label="Toggle legend" title="Toggle legend">▸</div>
    </header>
    <div class="rows" id="legend-rows"></div>
  </div>

  <!-- Three.js, 3d-force-graph, PapaParse -->
  <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/3d-force-graph"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
  // ===== CSV candidates (same folder) =====
  const CSV_CANDIDATES = [
    'table.csv','table - export.csv','table (export).csv',
    'the poppy board.csv','the poppy board v2.csv',
    'the poppy board, v2 28b95a1c19ee80249fb2fd23fc0b9532.csv'
  ];
  async function fetchFirstCsv() {
    for (const name of CSV_CANDIDATES) {
      try { const res = await fetch(name, { cache: 'no-cache' }); if (res.ok) return await res.text(); } catch {}
    }
    throw new Error('CSV not found. Add your filename to CSV_CANDIDATES (must contain "table" or "the poppy board").');
  }

  // Flexible columns
  const COLNAMES = {
    id: ['id','node id','uid','slug'],
    name: ['name','title','label'],
    tags: ['tag','tags','category','categories'], // Universe cluster
    size: ['size','val','value','weight'],       // 1..30 (string or number or "(X) text")
    sequels: ['sequels','sequel','next','edges','to'],
    collision: ['collision','collisions','collide','also to'],
    url: ['url','link','href','permalink']
  };

  // ===== Palette: poppy → pink → purple → cyan =====
  const TAG_PALETTE = [
    '#FF1447', '#FF2E7A', '#FF5AC8', '#C243FF',
    '#8A3DFF', '#4F6CFF', '#1CC6FF', '#00E5FF'
  ];
  function lerp(a,b,t){return a+(b-a)*t;}
  function hexToRgb(hex){const s=String(hex).replace('#','');return {r:parseInt(s.slice(0,2),16),g:parseInt(s.slice(2,4),16),b:parseInt(s.slice(4,6),16)};}
  function rgbToHex(r,g,b){const h=v=>v.toString(16).padStart(2,'0');return '#'+h(r)+h(g)+h(b);}
  function extendCool(i){
    const a = hexToRgb(TAG_PALETTE[TAG_PALETTE.length-2]);
    const b = hexToRgb(TAG_PALETTE[TAG_PALETTE.length-1]);
    const t = (i % 6) / 6;
    return rgbToHex(Math.round(lerp(a.r,b.r,t)), Math.round(lerp(a.g,b.g,t)), Math.round(lerp(a.b,b.b,t)));
  }

  // ===== Random scatter & animation knobs =====
  const BOX = 2200;   // scatter range: [-BOX, BOX] on each axis
  const EXPLODE_MS = 1400;
  const CAM_FLY_MS = 1600;
  const START_Z = 5200;
  const END_Z   = 1700;

  // Utils
  function normalizeHeaders(fields){const m={};(fields||[]).forEach(f=>{m[String(f||'').trim().toLowerCase()]=f;});return m;}
  function pick(headers, aliases){for(const a of aliases){const k=a.toLowerCase();if(k in headers) return headers[k];for(const key in headers){if(key.includes(k)) return headers[key];}}return null;}
  function splitIdsFlexible(s){if(s==null) return [];const raw=String(s).trim();if(!raw) return [];return raw.split(/[\s,;|]+/).map(t=>t.trim()).filter(Boolean).map(t=>Number(t)).filter(n=>Number.isFinite(n));}
  function parseParenNumber(s,fb=null){const m=/\(\s*([-+]?\d*\.?\d+)\s*\)/.exec(String(s||''));return m?Number(m[1]):fb;}
  function toSize(s){ // 1..30, from "(X) text" or raw number
    const fromParen = parseParenNumber(s);
    const n = (fromParen!=null ? fromParen : (s==null||s==='' ? 5 : Number(s)));
    const v = Number.isFinite(n) ? n : 5;
    return Math.max(1, Math.min(30, v));
  }
  function escapeHtml(s){return String(s||'').replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));}

  // Seeded randomness
  function hash32(str){let h=2166136261>>>0; for(let i=0;i<str.length;i++){h^=str.charCodeAt(i);h=Math.imul(h,16777619);} return h>>>0;}
  function rand(seed){ seed = (seed + 0x6D2B79F5) >>> 0; let t = Math.imul(seed ^ (seed >>> 15), 1 | seed); t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t; return ((t ^ (t >>> 14)) >>> 0) / 4294967296; }
  const EASE_OUT_CUBIC = t => 1 - Math.pow(1 - t, 3);

  // ====== load data ======
  fetchFirstCsv()
    .then(txt => new Promise(res => Papa.parse(txt,{header:true,dynamicTyping:false,skipEmptyLines:true,complete:res})))
    .then(result => {
      const rows = result.data||[];
      if(!rows.length) throw new Error('CSV has no rows');

      const headers = normalizeHeaders(result.meta.fields||Object.keys(rows[0]||{}));
      const col = {
        id: pick(headers,COLNAMES.id) || pick(headers,COLNAMES.name),
        name: pick(headers,COLNAMES.name),
        tags: pick(headers,COLNAMES.tags),
        size: pick(headers,COLNAMES.size),
        sequels: pick(headers,COLNAMES.sequels),
        collision: pick(headers,COLNAMES.collision),
        url: pick(headers,COLNAMES.url)
      };
      if(!col.id || !col.tags) throw new Error('Need at least ID/NAME and TAG columns');

      // ---------- Nodes (random scatter targets, explode from origin) ----------
      const nodes = rows.map(r=>{
        const id = String(r[col.id] ?? '').trim();
        const label = String(r[col.name] ?? id).trim() || id;
        const cluster = String(r[col.tags] ?? '').trim() || '(unclustered)';
        if(!id || !cluster) return null;

        const url = ((r[col.url] ?? '') + '').trim() || null;
        const val = toSize(r[col.size]);

        const seed = hash32(id);
        const tx = (rand(seed)*2-1) * BOX;
        const ty = (rand(seed+1)*2-1) * BOX;
        const tz = (rand(seed+2)*2-1) * BOX;

        // start near origin for explode
        const startJ = 6;
        const sx = (rand(seed+3)-0.5)*startJ;
        const sy = (rand(seed+4)-0.5)*startJ;
        const sz = (rand(seed+5)-0.5)*startJ;

        return { id, label, cluster, url, val,
                 x:sx, y:sy, z:sz, fx:sx, fy:sy, fz:sz,
                 tx, ty, tz,
                 _dbg:{seed} };
      }).filter(Boolean);

      // maps for links
      const nodeById = new Map(), nodeByNum = new Map();
      nodes.forEach(n=>{ nodeById.set(String(n.id), n); const num=Number(n.id); if(Number.isFinite(num)) nodeByNum.set(num, n); });

      // Universe cluster → color
      const clusterOrder=[], seen=new Set(), clusterColor={};
      nodes.forEach(n=>{ if(!seen.has(n.cluster)){seen.add(n.cluster); clusterOrder.push(n.cluster);} });
      clusterOrder.forEach((t,i)=>{ clusterColor[t]= i<TAG_PALETTE.length ? TAG_PALETTE[i] : extendCool(i-TAG_PALETTE.length); });
      nodes.forEach(n=> n.color = clusterColor[n.cluster]);

      // ensure node for stubs
      function ensureNodeForId(raw){
        const key = String(raw);
        let node = nodeById.get(key);
        if (node) return node;
        node = { id:key, label:key, cluster:'(referenced)', url:null, val:5, color:'#00E5FF',
                 x:0,y:0,z:0, fx:0,fy:0,fz:0, tx:0,ty:0,tz:0, _dbg:{seed:0} };
        nodes.push(node);
        nodeById.set(key, node);
        const num=Number(key); if(Number.isFinite(num)) nodeByNum.set(num, node);
        return node;
      }

      // ---------- Links (thin, robust, 0 = link to all) ----------
      const links = [];
      function addLinkByIds(srcId, tgtId){
        if(!srcId || !tgtId) return;
        if(String(srcId) === String(tgtId)) return;
        const srcNode = ensureNodeForId(srcId);
        const tgtNode = ensureNodeForId(tgtId);
        links.push({ source: srcNode, target: tgtNode, color:'#FFFFFF', width:0.9 });
      }
      rows.forEach(r=>{
        const srcRaw = String(r[col.id] ?? '').trim();
        if(!srcRaw) return;
        const seq = splitIdsFlexible(r[col.sequels]);
        const coln = splitIdsFlexible(r[col.collision]);
        const targets = [...seq, ...coln];
        if (targets.includes(0)) {
          nodes.forEach(n => { if (String(n.id) !== srcRaw) addLinkByIds(srcRaw, n.id); });
          return;
        }
        targets.forEach(num=>{
          if (num === 0) return;
          const tgt = nodeByNum.get(num) || nodeById.get(String(num)) || ensureNodeForId(num);
          addLinkByIds(srcRaw, tgt.id);
        });
      });

      // Legend build + toggle
      const legend=document.getElementById('legend'),
            rowsEl=document.getElementById('legend-rows'),
            toggleEl=document.getElementById('legend-toggle');
      rowsEl.innerHTML='';
      clusterOrder.forEach(t=>{
        const row=document.createElement('div'); row.className='row';
        const sw=document.createElement('div'); sw.className='swatch'; sw.style.background=clusterColor[t]; sw.style.boxShadow=`0 0 12px ${clusterColor[t]}`;
        const la=document.createElement('div'); la.className='label'; la.textContent=t;
        row.appendChild(sw); row.appendChild(la); rowsEl.appendChild(row);
      });
      legend.hidden=false;
      toggleEl.addEventListener('click', ()=>{
        legend.classList.toggle('collapsed');
        const chevron = legend.querySelector('.toggle');
        chevron.textContent = legend.classList.contains('collapsed') ? '▸' : '▾';
      });

      // ---- Glow (idle tinted to node color; big/bright on hover) ----
      const glowTexCache={};
      function makeGlowTexture(hex){
        if(glowTexCache[hex]) return glowTexCache[hex];
        const {r,g,b}=hexToRgb(hex); const size=256;
        const canvas=document.createElement('canvas'); canvas.width=canvas.height=size;
        const ctx=canvas.getContext('2d');
        const grd=ctx.createRadialGradient(size/2,size/2,size*0.06,size/2,size/2,size*0.55);
        grd.addColorStop(0.00,'rgba(255,255,255,0.85)');
        grd.addColorStop(0.18,`rgba(${r},${g},${b},0.45)`);
        grd.addColorStop(0.60,`rgba(${r},${g},${b},0.18)`);
        grd.addColorStop(1.00,'rgba(0,0,0,0)');
        ctx.fillStyle=grd; ctx.fillRect(0, 0, size, size);
        const tex=new THREE.CanvasTexture(canvas); tex.needsUpdate=true; glowTexCache[hex]=tex; return tex;
      }
      function makeGlowSprite(hex){
        const map=makeGlowTexture(hex);
        const mat=new THREE.SpriteMaterial({
          map, color:0xffffff, transparent:true, depthWrite:false,
          blending:THREE.AdditiveBlending, opacity:0.30
        });
        const spr=new THREE.Sprite(mat); spr.scale.set(1,1,1); return spr;
      }

      // --------- Build Graph ---------
      const elem = document.getElementById('g');
      let hoveredNode=null, pulseRAF=null;

      const Graph = ForceGraph3D()(elem)
        .enablePointerInteraction(true)
        .graphData({ nodes, links })
        .backgroundColor('#000014')
        .showNavInfo(false)
        .d3Force('link', null)
        .d3Force('charge', null)
        .enableNodeDrag(false)
        .cooldownTicks(0)
        .nodeThreeObject(n => {
          const colorHex = n.color || '#FF1447';
          const color = new THREE.Color(colorHex);
          const baseRadius=5;

          const core = new THREE.Mesh(
            new THREE.SphereGeometry(baseRadius,24,24),
            new THREE.MeshStandardMaterial({ color, metalness:0.12, roughness:0.38 })
          );

          // size: map 1..30 roughly to visual scale
          // base scale factor: 3.0 at size=10; grow slower beyond that
          const size = Math.max(1, Math.min(30, n.val || 5));
          const s = (size / 10) * 3.0; // linear; tweak if you want gamma
          core.scale.set(s,s,s);

          // Idle glow: medium, tinted
          const glow=makeGlowSprite(colorHex);
          const idleSize = baseRadius*s*8;
          glow.scale.set(idleSize,idleSize,1);
          glow.material.opacity = 0.30;
          core.add(glow);

          n.__core=core; n.__glow=glow; n.__sizeScale=s; n.__idleSize=idleSize; n.__idleOpacity=0.30;
          return core;
        })
        // Tooltips for ALL nodes
        .nodeLabel(n => {
          const hint = n.url ? '<span class="hint">Click to open archive</span>' : '<span class="hint">URL: N/A</span>';
          const cl = n.cluster ? `<br><span style="opacity:.9; font-size: 16px">Universe cluster: ${escapeHtml(n.cluster)}</span>` : '';
          return `<div class="poppy-label"><b>${escapeHtml(n.label || n.id)}</b>${cl}<br>${hint}</div>`;
        })
        .linkColor(l => l.color || '#FFFFFF')
        .linkWidth(l => l.width || 0.9)
        .linkOpacity(0.7);

      // Lights
      const scene=Graph.scene();
      scene.add(new THREE.AmbientLight(0xffffff,0.35));
      const dir=new THREE.DirectionalLight(0xffffff,0.6); dir.position.set(60,80,40); scene.add(dir);

      // Controls + camera fly
      const controls=Graph.controls();
      controls.enableRotate=true; controls.enablePan=true; controls.minDistance=20; controls.maxDistance=30000;
      controls.target.set(0,0,0); controls.update();
      Graph.cameraPosition({x:0,y:0,z:START_Z},{x:0,y:0,z:0},0);
      setTimeout(()=>{ Graph.cameraPosition({x:0,y:0,z:END_Z},{x:0,y:0,z:0},CAM_FLY_MS); }, 30);

      // ---------- Explode animation ----------
      const t0 = performance.now();
      function animateExplode(now){
        const t = Math.min(1, (now - t0) / EXPLODE_MS);
        const e = EASE_OUT_CUBIC(t);
        for(const n of nodes){
          n.x = n.fx = n.tx * e + n.fx * (1 - e);
          n.y = n.fy = n.ty * e + n.fy * (1 - e);
          n.z = n.fz = n.tz * e + n.fz * (1 - e);
        }
        if (t < 1) requestAnimationFrame(animateExplode);
        else {
          for (const n of nodes) {
            n.x = n.fx = n.tx; n.y = n.fy = n.ty; n.z = n.fz = n.tz;
            console.log('%c[NODE]', 'color:#FF1447;font-weight:bold',
              n.label || n.id, '→', { x:n.x, y:n.y, z:n.z, seed:n._dbg?.seed }
            );
          }
        }
      }
      requestAnimationFrame(animateExplode);

      // Hover pulse: BIG + bright on hover, revert to idle when out
      function pulse(){
        if(!hoveredNode || !hoveredNode.__glow || !hoveredNode.__core){ pulseRAF=requestAnimationFrame(pulse); return; }
        const t=(Date.now()%1200)/1200;
        const amp = 1 + 0.22 * Math.sin(t * Math.PI * 2);
        const opacity = 0.40 + 0.35 * (0.5 + 0.5 * Math.sin(t * Math.PI * 2));

        const b=hoveredNode.__sizeScale;
        hoveredNode.__core.scale.set(b*1.06,b*1.06,b*1.06);

        const big = hoveredNode.__idleSize * 1.8;
        hoveredNode.__glow.scale.set(big*amp, big*amp, 1);
        hoveredNode.__glow.material.opacity = opacity;

        pulseRAF=requestAnimationFrame(pulse);
      }

      Graph
        .onNodeHover((node, prev)=>{
          if(prev && prev.__core && prev.__glow){
            const b=prev.__sizeScale;
            prev.__core.scale.set(b,b,b);
            prev.__glow.scale.set(prev.__idleSize, prev.__idleSize, 1);
            prev.__glow.material.opacity = prev.__idleOpacity;
          }
          hoveredNode=node||null;
          if(hoveredNode){ 
            elem.style.cursor='pointer';
            if(!pulseRAF) pulseRAF=requestAnimationFrame(pulse);
          } else {
            elem.style.cursor=null;
            if(pulseRAF){ cancelAnimationFrame(pulseRAF); pulseRAF=null; }
          }
        })
        .onNodeClick(n=>{ if(n.url) window.open(n.url,'_blank','noopener'); });

      // console.log(`nodes: ${nodes.length}, links: ${links.length}`);
    })
    .catch(err => {
      document.body.innerHTML = '<pre style="color:#fff; padding:16px">'+String(err)+'</pre>';
      console.error(err);
    });
  </script>
</body>
</html>
